# TheoryOfComputation
V13Q1)**Yanda verilen DFA modelinin iÃ§erikten baÄŸÄ±msÄ±z dil gramer kurallarÄ±nÄ± tanÄ±mlayÄ±nÄ±z.** (*Define the context-free language grammar rules of the DFA model given below*)
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2013/2013VisaQ1.png)

V13Q4)**DÃ¼zenli ifadesi a U ba\* U ab\*a olan dilin DFA modelini Ã§iziniz.** (*Draw the DFA model of regular expression a U ba\* U ab\*a*)
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2013/2013VisaQ4.png)

V13Q5)**DÃ¼zenli bir dil olarak {a, b} alfabesi Ã¼zerinde tanÄ±mlanan L diline ait kelimelerin ne
baÅŸÄ±nda ne de sonunda aa veya bb bulunur. Buna gÃ¶re L dilinin NFA modelini Ã§iziniz.** (*Language L defined on the {a, b} alphabet as a regular language. It does not have aa or bb at the beginning nor at the end. Draw the NFA model of language L*)
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2013/2013VisaQ5.png)

V13Q6)**AÅŸaÄŸÄ±daki iÃ§erikten baÄŸÄ±msÄ±z dil gramer kurallarÄ±nÄ± kullanarak bir yÄ±ÄŸÄ±nlÄ± otomata tasarlayÄ±nÄ±z.** (*Design a PDA using the following context-free language grammar rules*)
**Sâ†’aB | bA &nbsp;&nbsp;&nbsp;&nbsp; Aâ†’a | aS | bAA | c &nbsp;&nbsp;&nbsp;&nbsp; Bâ†’b | bS | aBB | c**
<pre>
First, convert it into CNF.<br>
S'-> S<br>
S -> CB | DA<br>
A -> C | CS | DF | E<br>
B -> D | DS | CG | E<br>
C -> a<br>
D -> b<br>
E -> c<br>
F -> AA<br>
G -> BB<br>

S: qa$ -> qNBC   A:  qa$ -> qNC   qa$ -> qNFD   B:  qa$ -> qND   qa$ -> qNGC   C:  qaC -> qRâ‚¬   F: qa$ -> qNAA<br>
   qb$ -> qNBC       qb$ -> qNC   qb$ -> qNFD       qb$ -> qND   qb$ -> qNGC   D:  qaD -> qRâ‚¬      qa$ -> qNAA<br>
   qc$ -> qNBC       qc$ -> qNC   qc$ -> qNFD       qc$ -> qND   qc$ -> qNGC   E:  qaE -> qRâ‚¬      qa$ -> qNAA<br>

   qa$ -> qNAD       qa$ -> qNSC  qa$ -> qNE        qa$ -> qNSD  qa$ -> qNE    G:  qa$ -> qNBB <br>
   qb$ -> qNAD       qb$ -> qNSC  qb$ -> qNE        qb$ -> qNSD  qb$ -> qNE        qb$ -> qNBB<br>
   qc$ -> qNAD       qc$ -> qNSC  qc$ -> qNE        qc$ -> qNSD  qc$ -> qNE        qc$ -> qNBB<br>
</pre>

or you can just use jflap to convert CFG to PDA
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2013/2013VisaQ6.png)

V19Q1)**A family members (2 parents and 2 children) wants to walk side by side on the road.
Each parent holds one childrenâ€™s hand. Both children can be in the middle or on the sides at the
same time. Design a NFA that accepts all possible walking situations.**
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2019/2019VisaQ1.png)

V19Q2)**Convert the DFA given below to Regular Expression.
<pre>
Lq1 = aLq1 U bLq3
Lq2 = aLq2 U bLq1
Lq3 = aLq1 U bLq2 U â‚¬

apply Arden's Theorem
Lq1 = a*bLq3
Lq2 = a*bLq1

Lq3 = aLq1 U b(a*bLq1) U â‚¬
Lq3 = a(a*bLq3) U b(a*b(a*bLq3)) U â‚¬
Lq3 = (aa*b U ba*ba*b)Lq3 U â‚¬
Lq3 = (aa*b U ba*ba*b)^*â‚¬
Lq3 = (aa*b U ba*ba*b)^*

Lq1 = aLq1 U b((aa*b U ba*ba*b)*)
Lq1 = a*b(aa*b U ba*ba*b)*
</pre>

or you can just use jflap to convert DFA to RegEx
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2019/2019VisaQ2.png)

V19Q3)**Write down the CFG rules of the grammar given below.  {ğ‘ğ‘^ğ‘›ğ‘^ğ‘›ğ‘ : n â‰¥ 0}
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2019/2019VisaQ3.png)

V19Q4)** Design a PDA that accepts the words generated by the grammar given below.  S â†’ AB|Îµ   A â†’ AA|a   B â†’ b
<pre>
First, convert it into CNF.<br>
S' -> S | â‚¬<br>
S -> AB<br>
A -> AA | a<br>
B -> b<br>

S: qa$ -> qNBA    A: qa$ -> qNAA    B:  qbB -> qRâ‚¬
   qb$ -> qNBA       qb$ -> qNAA         
                     qaA -> qRâ‚¬
</pre>
Above solution was rule-based. Instead you can make it by your mind with ease.
![answer](https://raw.githubusercontent.com/recepecem/TheoryOfComputation/main/Visa/2019/2019VisaQ4.png)
